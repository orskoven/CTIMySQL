==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/test/java/orsk/authmodule/security/SecurityTests.java
==============================
package orsk.authmodule.security;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

// Example for testing access to protected resources
@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class SecurityTests {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("Security Test: Access Protected Endpoint without JWT")
    public void testAccessProtectedEndpointWithoutJWT() throws Exception {
        mockMvc.perform(get("/api/protected/resource"))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("Security Test: Access Protected Endpoint with Invalid JWT")
    public void testAccessProtectedEndpointWithInvalidJWT() throws Exception {
        mockMvc.perform(get("/api/protected/resource")
                        .header("Authorization", "Bearer invalidtoken"))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @DisplayName("Security Test: Access Protected Endpoint with Valid JWT")
    public void testAccessProtectedEndpointWithValidJWT() throws Exception {
        // Assume you have a method to generate a valid JWT for testing
        String validJwt = generateValidJwt();

        mockMvc.perform(get("/api/protected/resource")
                        .header("Authorization", "Bearer " + validJwt))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON));
    }

    // Helper method to generate a valid JWT for testing purposes
    private String generateValidJwt() {
        // Implement logic to generate a valid JWT
        // This could involve using JwtTokenProvider or mocking the token
        return "mockedValidJwtToken"; // Placeholder
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/test/java/orsk/authmodule/integration/DatabaseIntegrationTest.java
==============================
package orsk.authmodule.integration;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;
import orsk.authmodule.model.Role;
import orsk.authmodule.model.User;
import orsk.authmodule.repository.RoleRepository;
import orsk.authmodule.repository.UserRepository;

import java.util.Optional;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
@Transactional
@DisplayName("Database Integration Tests for User Entity")
public class DatabaseIntegrationTest {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @BeforeEach
    public void setup() {
        // Clear the database to ensure test isolation
        userRepository.deleteAll();
        roleRepository.deleteAll();

        // Initialize ROLE_USER
        Role userRole = new Role();
        userRole.setName("ROLE_USER");
        roleRepository.save(userRole);
    }

    @Test
    @DisplayName("Test Saving and Retrieving a User")
    public void testSaveAndRetrieveUser() {
        // Arrange
        User user = new User();
        user.setUsername("testuser11");
        user.setEmail("testuser11@example.com");
        user.setPassword("password123");
        user.setEnabled(true);
        user.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));

        // Act
        User savedUser = userRepository.save(user);
        Optional<User> retrievedUser = userRepository.findById(savedUser.getId());

        // Assert
        assertNotNull(savedUser.getId(), "User ID should not be null after save.");
        assertTrue(retrievedUser.isPresent(), "Retrieved user should be present.");
        assertEquals("testuser11", retrievedUser.get().getUsername(), "Username should match.");
    }

    @Test
    @DisplayName("Test Unique Constraint Violation for Username")
    public void testUniqueConstraintOnUsername() {
        // Arrange
        User user1 = new User();
        user1.setUsername("duplicateuser");
        user1.setEmail("user1@example.com");
        user1.setPassword("password123");
        user1.setEnabled(true);
        user1.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));
        userRepository.save(user1);

        User user2 = new User();
        user2.setUsername("duplicateuser"); // Duplicate username
        user2.setEmail("user2@example.com");
        user2.setPassword("password456");
        user2.setEnabled(true);
        user2.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));

        // Act & Assert
        Exception exception = assertThrows(Exception.class, () -> userRepository.save(user2));
        assertTrue(exception.getMessage().contains("Duplicate entry") || exception.getCause().getMessage().contains("Duplicate entry"),
                "Exception should indicate duplicate entry.");
    }

    @Test
    @DisplayName("Test Find User By Email")
    public void testFindUserByEmail() {
        // Arrange
        User user = new User();
        user.setUsername("testuser1");
        user.setEmail("testuser1@example.com");
        user.setPassword("password123");
        user.setEnabled(true);
        user.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));
        userRepository.save(user);

        // Act
        Optional<User> foundUser = userRepository.findByEmail("testuser1@example.com");

        // Assert
        assertTrue(foundUser.isPresent(), "User should be found by email.");
        assertEquals("testuser1", foundUser.get().getUsername(), "Username should match the email.");
    }

    @Test
    @DisplayName("Test Non-Existent User By Email")
    public void testFindNonExistentUserByEmail() {
        // Act
        Optional<User> foundUser = userRepository.findByEmail("nonexistent@example.com");

        // Assert
        assertFalse(foundUser.isPresent(), "No user should be found for a non-existent email.");
    }

    @Test
    @DisplayName("Test Updating a User")
    public void testUpdateUser() {
        // Arrange
        User user = new User();
        user.setUsername("testuser1");
        user.setEmail("testuser1@example.com");
        user.setPassword("password123");
        user.setEnabled(true);
        user.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));
        User savedUser = userRepository.save(user);

        // Act
        savedUser.setEmail("updated@example.com");
        userRepository.save(savedUser);
        Optional<User> updatedUser = userRepository.findById(savedUser.getId());

        // Assert
        assertTrue(updatedUser.isPresent(), "Updated user should be found.");
        assertEquals("updated@example.com", updatedUser.get().getEmail(), "Email should be updated.");
    }

    @Test
    @DisplayName("Test Deleting a User")
    public void testDeleteUser() {
        // Arrange
        User user = new User();
        user.setUsername("testuser1");
        user.setEmail("testuser1@example.com");
        user.setPassword("password123");
        user.setEnabled(true);
        user.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));
        User savedUser = userRepository.save(user);

        // Act
        userRepository.deleteById(savedUser.getId());
        Optional<User> deletedUser = userRepository.findById(savedUser.getId());

        // Assert
        assertFalse(deletedUser.isPresent(), "User should no longer exist after deletion.");
    }

    @Test
    @DisplayName("Test Invalid Data Handling (Null Fields)")
    public void testInvalidDataHandling() {
        // Arrange
        User user = new User();
        user.setUsername(null); // Null username should cause a constraint violation
        user.setEmail("invalid@example.com");
        user.setPassword("password123");
        user.setEnabled(true);
        user.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));

        // Act & Assert
        Exception exception = assertThrows(Exception.class, () -> userRepository.save(user));
        assertTrue(exception.getMessage().contains("ConstraintViolationException") ||
                        exception.getCause().getMessage().contains("NOT NULL") ||
                        exception.getCause().getMessage().contains("NULL"),
                "Exception should indicate a constraint violation.");
    }

    @Test
    @DisplayName("Test Find All Users")
    public void testFindAllUsers() {
        // Arrange
        User user1 = new User();
        user1.setUsername("user1");
        user1.setEmail("user1@example.com");
        user1.setPassword("password123");
        user1.setEnabled(true);
        user1.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));

        User user2 = new User();
        user2.setUsername("user2");
        user2.setEmail("user2@example.com");
        user2.setPassword("password456");
        user2.setEnabled(true);
        user2.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));

        userRepository.save(user1);
        userRepository.save(user2);

        // Act
        Iterable<User> users = userRepository.findAll();

        // Assert
        assertNotNull(users, "Users should not be null.");
        assertTrue(users.iterator().hasNext(), "Users list should not be empty.");
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/test/java/orsk/authmodule/integration/AuthIntegrationTest.java
==============================
package orsk.authmodule.integration;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class AuthIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("Test Successful Authentication")
    public void testSuccessfulAuthentication() throws Exception {
        // Arrange: Prepare valid user credentials
        String validCredentials = """
        {
            "email": "testuser@example.com",
            "password": "password123"
        }
        """;

        // Act: Perform the sign-in request
        ResultActions response = mockMvc.perform(
                post("/api/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(validCredentials)
        );

        // Assert: Verify the response
        response.andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").exists())
                .andExpect(jsonPath("$.accessToken").isNotEmpty())
                .andExpect(jsonPath("$.refreshToken").exists())
                .andExpect(jsonPath("$.refreshToken").isNotEmpty())
                .andExpect(jsonPath("$.tokenType").value("Bearer"));
    }

    @Test
    @DisplayName("Test Authentication with Invalid Credentials")
    public void testAuthenticationInvalidCredentials() throws Exception {
        String invalidCredentials = """
            {
                "email": "testuser@example.com",
                "password": "wrongpassword"
            }
        """;

        ResultActions response = mockMvc.perform(
                post("/api/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(invalidCredentials)
        );

        response.andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.error").value("Invalid email or password"));
    }

    @Test
    @DisplayName("Test Authentication with Missing Fields")
    public void testAuthenticationMissingFields() throws Exception {
        String incompleteCredentials = """
            {
                "email": "testuser@example.com"
            }
        """;

        ResultActions response = mockMvc.perform(
                post("/api/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(incompleteCredentials)
        );

        response.andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.validationErrors").exists());
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/test/java/orsk/authmodule/system/AuthenticationFlowTest.java
==============================
package orsk.authmodule.system;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;
import orsk.authmodule.dto.*;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class AuthenticationFlowTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("System Test: Complete Registration and Login with MFA")
    public void testCompleteAuthenticationFlow() throws Exception {
        // Step 1: Register User
        RegistrationRequest registrationRequest = new RegistrationRequest();
        registrationRequest.setUsername("flowUser");
        registrationRequest.setEmail("flowuser@example.com");
        registrationRequest.setPassword("StrongPassword@123");
        registrationRequest.setConsentToDataUsage(true);

        mockMvc.perform(post("/api/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(registrationRequest)))
                .andExpect(status().isCreated())
                .andExpect(content().string("User registered successfully. Please check your email for verification instructions."));

        // Step 2: Simulate Email Verification
        // In a real scenario, retrieve the token from the email or database
        // For testing, fetch the token from the database or mock the VerificationTokenService

        // Assuming a token retrieval method exists
        String verificationToken = fetchVerificationToken("flowuser@example.com");

        mockMvc.perform(post("/api/auth/verify-email")
                        .param("token", verificationToken))
                .andExpect(status().isOk())
                .andExpect(content().string("Email verified successfully."));

        // Step 3: Login User (Assume MFA is required)
        LoginRequest loginRequest = new LoginRequest();
        loginRequest.setEmail("flowuser@example.com");
        loginRequest.setPassword("StrongPassword@123");

        mockMvc.perform(post("/api/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequest)))
                .andExpect(status().isForbidden())
                .andExpect(content().string("MFA verification required"));

        // Step 4: Verify MFA (Assume MFA code is '123456')
        // In reality, the MFA code would be sent to the user; retrieve it from the database or mock
        String mfaCode = fetchMfaCode("flowUser");

        MfaVerificationRequest mfaRequest = new MfaVerificationRequest();
        mfaRequest.setMfaCode(mfaCode);

        mockMvc.perform(post("/api/auth/verify-mfa")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(mfaRequest)))
                .andExpect(status().isOk())
                .andExpect(content().string("MFA verification successful."));

        // Step 5: Confirm Successful Login Post-MFA
        // Depending on your application's flow, you might need to perform additional steps
        // For example, retrieve JWT and verify access to protected resources
    }

    // Helper methods to retrieve tokens and MFA codes for testing purposes
    private String fetchVerificationToken(String email) {
        // Implement logic to fetch the verification token from the database
        // This could involve querying the VerificationTokenRepository
        // For example:
        // return verificationTokenRepository.findByUserEmail(email).getToken();
        return "mockedVerificationToken"; // Placeholder
    }

    private String fetchMfaCode(String username) {
        // Implement logic to fetch the MFA code from the database
        // This could involve querying the MfaTokenRepository
        // For example:
        // return mfaTokenRepository.findByUserUsername(username).getMfaCode();
        return "123456"; // Placeholder
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/test/java/orsk/authmodule/AuthmoduleApplicationTests.java
==============================
package orsk.authmodule;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AuthmoduleApplicationTests {

    @Test
    void contextLoads() {
    }

}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/test/java/orsk/authmodule/controllers/AuthControllerTest.java
==============================
package orsk.authmodule.controllers;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
public class AuthControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testSignIn() throws Exception {
        mockMvc.perform(post("/api/auth/login")
                        .contentType("application/json")
                        .content("{\"email\": \"testuser@example.com\", \"password\": \"password\"}"))
                .andExpect(status().isOk());
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/test/java/orsk/authmodule/controllers/AuthControllerUnitTest.java
==============================
package orsk.authmodule.controllers;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import orsk.authmodule.controller.AuthController;
import orsk.authmodule.dto.*;
import orsk.authmodule.exceptions.*;
import orsk.authmodule.service.AuthService;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(AuthController.class)
public class AuthControllerUnitTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private AuthService authService;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("Unit Test: Successful User Registration")
    public void testRegisterUser_Success() throws Exception {
        RegistrationRequest request = new RegistrationRequest();
        request.setUsername("unitUser");
        request.setEmail("unit@example.com");
        request.setPassword("StrongPassword@123");
        request.setConsentToDataUsage(true);

        doNothing().when(authService).registerUser(any(RegistrationRequest.class));

        mockMvc.perform(post("/api/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isCreated())
                .andExpect(content().string("User registered successfully. Please check your email for verification instructions."));
    }

    @Test
    @DisplayName("Unit Test: User Registration with Existing Email")
    public void testRegisterUser_Conflict() throws Exception {
        RegistrationRequest request = new RegistrationRequest();
        request.setUsername("unitUser");
        request.setEmail("existing@example.com");
        request.setPassword("StrongPassword@123");
        request.setConsentToDataUsage(true);

        doThrow(new UserAlreadyExistsException("Username or email already exists"))
                .when(authService).registerUser(any(RegistrationRequest.class));

        mockMvc.perform(post("/api/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isConflict())
                .andExpect(content().string("Username or email already exists"));
    }

    // Additional unit tests for login, email verification, MFA verification, etc.
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/test/java/orsk/authmodule/services/AuthServiceTest.java
==============================
package orsk.authmodule.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.crypto.password.PasswordEncoder;
import orsk.authmodule.dto.*;
import orsk.authmodule.exceptions.UserAlreadyExistsException;
import orsk.authmodule.model.Role;
import orsk.authmodule.model.User;
import orsk.authmodule.repository.*;
import orsk.authmodule.security.JwtTokenProvider;

import java.util.Optional;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

public class AuthServiceTest {

    @InjectMocks
    private AuthService authService;

    @Mock
    private AuthenticationManager authenticationManager;

    @Mock
    private UserRepository userRepository;

    @Mock
    private RoleRepository roleRepository;

    @Mock
    private VerificationTokenRepository verificationTokenRepository;

    @Mock
    private PasswordResetTokenRepository passwordResetTokenRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @Mock
    private JwtTokenProvider tokenProvider;

    @Mock
    private RefreshTokenService refreshTokenService;

    @Mock
    private MfaTokenService mfaTokenService;

    @Mock
    private AuditLogService auditLogService;

    @BeforeEach
    public void setup() {
        // Clear existing data
        userRepository.deleteAll();
        roleRepository.deleteAll();

        // Initialize ROLE_USER
        Role userRole = new Role();
        userRole.setName("ROLE_USER");
        roleRepository.save(userRole);
    }

    @Test
    @DisplayName("Register User Successfully")
    public void testRegisterUser_Success() {
        // Arrange
        RegistrationRequest request = new RegistrationRequest();
        request.setUsername("newuser");
        request.setEmail("newuser@example.com");
        request.setPassword("StrongPassword@123");
        request.setConsentToDataUsage(true);

        when(userRepository.existsByUsernameOrEmail(anyString(), anyString())).thenReturn(false);

        Role role = new Role();
        role.setName("ROLE_USER");
        when(roleRepository.findByName("ROLE_USER")).thenReturn(Optional.of(role));

        when(passwordEncoder.encode(anyString())).thenReturn("hashedPassword");

        // Act
        assertDoesNotThrow(() -> authService.registerUser(request));

        // Assert
        verify(userRepository, times(1)).save(any(User.class));
        verify(verificationTokenRepository, times(1)).save(any());
        verify(auditLogService, times(1)).logAction(any(), eq("USER_REGISTERED"), any(), any());
    }

    @Test
    @DisplayName("Register User with Existing Username or Email")
    public void testRegisterUser_UserAlreadyExists() {
        // Arrange
        RegistrationRequest request = new RegistrationRequest();
        request.setUsername("existinguser");
        request.setEmail("existinguser@example.com");
        request.setPassword("StrongPassword@123");
        request.setConsentToDataUsage(true);

        when(userRepository.existsByUsernameOrEmail(anyString(), anyString())).thenReturn(true);

        // Act & Assert
        UserAlreadyExistsException exception = assertThrows(UserAlreadyExistsException.class, () -> authService.registerUser(request));
        assertEquals("Username or email already exists", exception.getMessage());

        verify(userRepository, never()).save(any(User.class));
        verify(verificationTokenRepository, never()).save(any());
        verify(auditLogService, never()).logAction(any(), any(), any(), any());
    }

    // Additional unit tests for other methods (login, password reset, etc.)
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/test/java/orsk/authmodule/services/AuthServiceIntegrationTest.java
==============================
package orsk.authmodule.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.security.crypto.password.PasswordEncoder;
import orsk.authmodule.dto.RegistrationRequest;
import orsk.authmodule.exceptions.UserAlreadyExistsException;
import orsk.authmodule.model.Role;
import orsk.authmodule.model.User;
import orsk.authmodule.repository.RoleRepository;
import orsk.authmodule.repository.UserRepository;

import java.util.Optional;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@SpringBootTest
public class AuthServiceIntegrationTest {

    @Autowired
    private AuthService authService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @MockBean
    private AuditLogService auditLogService;


    @BeforeEach
    public void setup() {
        userRepository.deleteAll();
        roleRepository.deleteAll();

        // Initialize ROLE_USER
        Role userRole = new Role();
        userRole.setName("ROLE_USER");
        roleRepository.save(userRole);
    }

    @Test
    @DisplayName("Integration Test: Register User Successfully")
    public void testRegisterUser_Success() {
        RegistrationRequest request = new RegistrationRequest();
        request.setUsername("integrationUser");
        request.setEmail("integration@example.com");
        request.setPassword("StrongPassword@123");
        request.setConsentToDataUsage(true);

        assertDoesNotThrow(() -> authService.registerUser(request));

        Optional<User> userOpt = userRepository.findByEmail("integration@example.com");
        assertTrue(userOpt.isPresent());
        User user = userOpt.get();
        assertEquals("integrationUser", user.getUsername());
        assertTrue(passwordEncoder.matches("StrongPassword@123", user.getPassword()));
        assertFalse(user.getEnabled());
        assertEquals(Set.of(roleRepository.findByName("ROLE_USER").get()), user.getRoles());

        // Verify audit logging
        verify(auditLogService, times(1)).logAction(eq(user), eq("USER_REGISTERED"), anyString(), anyString());
    }

    @Test
    @DisplayName("Integration Test: Register User with Existing Username")
    public void testRegisterUser_ExistingUsername() {
        // Arrange
        User existingUser = new User();
        existingUser.setUsername("existingUser");
        existingUser.setEmail("existing@example.com");
        existingUser.setPassword(passwordEncoder.encode("password123"));
        existingUser.setEnabled(true);
        existingUser.setConsentToDataUsage(true);
        existingUser.setRoles(Set.of(roleRepository.findByName("ROLE_USER").get()));
        userRepository.save(existingUser);

        RegistrationRequest request = new RegistrationRequest();
        request.setUsername("existingUser");
        request.setEmail("newemail@example.com");
        request.setPassword("StrongPassword@123");
        request.setConsentToDataUsage(true);

        // Act & Assert
        UserAlreadyExistsException exception = assertThrows(UserAlreadyExistsException.class, () -> authService.registerUser(request));
        assertEquals("Username or email already exists", exception.getMessage());

        // Verify that no new user is created
        assertEquals(1, userRepository.count());

        // Verify audit logging was not called
        verify(auditLogService, never()).logAction(any(), any(), anyString(), anyString());
    }

    // Additional integration tests for login, MFA, password reset, etc.
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/MfaVerificationRequest.java
==============================
package orsk.authmodule.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class MfaVerificationRequest {

    @NotBlank(message = "MFA code is required")
    private String mfaCode;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/RegistrationRequest.java
==============================
package orsk.authmodule.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class RegistrationRequest {

    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;

    @NotBlank(message = "Password is required")
    @Size(min = 12, message = "Password must be at least 12 characters")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&#^()_+{}|:;<>,.?/~`-]).+$",
            message = "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character")
    private String password;

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;

    private Boolean consentToDataUsage = false;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/LogoutRequest.java
==============================
package orsk.authmodule.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LogoutRequest {

    @NotBlank(message = "Refresh token is required")
    private String refreshToken;
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/TokenRefreshRequest.java
==============================
package orsk.authmodule.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class TokenRefreshRequest {

    @NotBlank(message = "Refresh token is required")
    private String refreshToken;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/LoginRequest.java
==============================
package orsk.authmodule.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LoginRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    @NotBlank(message = "Password is required")
    private String password;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/PasswordResetRequest.java
==============================
package orsk.authmodule.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PasswordResetRequest {

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/UserDTO.java
==============================
package orsk.authmodule.dto;

public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private boolean enabled;

    // Getters and Setters
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/JwtAuthenticationResponse.java
==============================
package orsk.authmodule.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class JwtAuthenticationResponse {

    private String accessToken;
    private String refreshToken;
    private String tokenType = "Bearer";

    public JwtAuthenticationResponse(String accessToken, String refreshToken) {
        this.accessToken = accessToken;
        this.refreshToken = refreshToken;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/PasswordChangeRequest.java
==============================
package orsk.authmodule.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PasswordChangeRequest {

    @NotBlank(message = "Reset token is required")
    private String token;

    @NotBlank(message = "New password is required")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&#^()_+{}|:;<>,.?/~`-]).+$",
            message = "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character")
    private String newPassword;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/dto/SearchOptionsResponse.java
==============================
// File: src/main/java/orsk/compli/dtos/SearchOptionsResponse.java

package orsk.authmodule.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.List;

@Data
@AllArgsConstructor
public class SearchOptionsResponse {
    private List<String> products;
    private List<String> countries;
    private List<String> threats;
    // Add more fields as needed
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/repository/RefreshTokenRepository.java
==============================
package orsk.authmodule.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.authmodule.model.RefreshToken;
import orsk.authmodule.model.User;

import java.util.Optional;

@Repository("RefreshTokenJpaRepository")
public interface RefreshTokenRepository extends JpaRepository<RefreshToken, Long> {
    Optional<RefreshToken> findByToken(String token);

    int deleteByUser(User user);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/repository/RoleRepository.java
==============================
package orsk.authmodule.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.authmodule.model.Role;

import java.util.Optional;

@Repository("RoleJpaRepository")
public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(String name);
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/repository/MfaTokenRepository.java
==============================
package orsk.authmodule.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.authmodule.model.MfaToken;

import java.util.Optional;

@Repository("MfaTokenJpaRepository")
public interface MfaTokenRepository extends JpaRepository<MfaToken, Long> {
    Optional<MfaToken> findByMfaCode(String mfaCode);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/repository/UserRepository.java
==============================
package orsk.authmodule.repository;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.authmodule.model.User;

import java.util.Optional;

@Repository("UserJpaRepository")
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);

    Optional<User> findByEmail(String email);

    boolean existsByUsernameOrEmail(String username, String email);

    Optional<User> findByPasswordResetTokens_Token(String token);
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/repository/PasswordResetTokenRepository.java
==============================
package orsk.authmodule.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.authmodule.model.PasswordResetToken;

import java.util.Optional;

@Repository("PasswordResetTokenJpaRepository")
public interface PasswordResetTokenRepository extends JpaRepository<PasswordResetToken, Long> {
    Optional<PasswordResetToken> findByToken(String token);
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/repository/VerificationTokenRepository.java
==============================
package orsk.authmodule.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.authmodule.model.User;
import orsk.authmodule.model.VerificationToken;

import java.util.Optional;

@Repository("VerificationTokenJpaRepository")
public interface VerificationTokenRepository extends JpaRepository<VerificationToken, Long> {
    Optional<VerificationToken> findByToken(String token);

    Optional<VerificationToken> findByUser(User user);
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/repository/AuditLogRepository.java
==============================
package orsk.authmodule.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.authmodule.model.AuditLog;

@Repository("AuditLogJpaRepository")
public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/repository/PrivilegeRepository.java
==============================
package orsk.authmodule.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import orsk.authmodule.model.Privilege;

import java.util.Optional;

@Repository("PrivilegeJpaRepository")
public interface PrivilegeRepository extends JpaRepository<Privilege, Long> {
    Optional<Privilege> findByName(String name);
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/security/SecurityConfig.java
==============================
package orsk.authmodule.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.util.Arrays;
import java.util.List;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final JwtAuthenticationEntryPoint unauthorizedHandler;

    public SecurityConfig(JwtAuthenticationEntryPoint unauthorizedHandler) {
        this.unauthorizedHandler = unauthorizedHandler;
    }

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(withDefaults()) // Enable CORS with default configuration
                .csrf(AbstractHttpConfigurer::disable) // Disable CSRF for stateless APIs
                .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll() // Allow OPTIONS requests
                        .requestMatchers("/api/auth/**").permitAll() // Public endpoints
                        .anyRequest().authenticated() // Secure other endpoints
                );

        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(List.of("http://localhost:5173")); // Update with your allowed origins
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);

        return new CorsFilter(source);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/security/JwtAuthenticationEntryPoint.java
==============================
package orsk.authmodule.security;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage());
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/security/JwtAuthenticationFilter.java
==============================
package orsk.authmodule.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.web.filter.OncePerRequestFilter;
import orsk.authmodule.service.CustomUserDetailsService;

import java.io.IOException;

public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtTokenProvider tokenProvider;

    @Autowired
    private CustomUserDetailsService customUserDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        try {
            String jwt = getJwtFromRequest(request);

            if (jwt != null && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromJWT(jwt);

                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                var authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());

                authentication.setDetails(new WebAuthenticationDetailsSource()
                        .buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("Could not set user authentication in security context", ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/security/JwtTokenProvider.java
==============================
package orsk.authmodule.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration.ms}")
    private int jwtExpirationInMs;

    private Key key;

    @PostConstruct
    public void init() {
        // Generate a secure key for HS512 using the configured jwtSecret
        if (jwtSecret != null && jwtSecret.length() >= 64) { // Ensure sufficient length for HS512
            key = Keys.hmacShaKeyFor(jwtSecret.getBytes());
        } else {
            throw new IllegalArgumentException("JWT secret key must be at least 64 characters long");
        }
    }

    public String generateToken(Authentication authentication) {
        String username = authentication.getName();
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);

        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    public String generateTokenFromUsername(String username) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);

        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    public String getUsernameFromJWT(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();

        return claims.getSubject();
    }

    public boolean validateToken(String authToken) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(authToken);
            return true;
        } catch (Exception ex) {
            // Log the exception or handle it as needed
        }
        return false;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/exceptions/ResourceNotFoundException.java
==============================
package orsk.authmodule.exceptions;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/exceptions/EmailNotFoundException.java
==============================
package orsk.authmodule.exceptions;

public class EmailNotFoundException extends RuntimeException {
    public EmailNotFoundException(String message) {
        super(message);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/exceptions/MfaRequiredException.java
==============================
package orsk.authmodule.exceptions;

public class MfaRequiredException extends RuntimeException {
    public MfaRequiredException(String message) {
        super(message);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/exceptions/GlobalExceptionHandler.java
==============================
package orsk.authmodule.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.time.Instant;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
                Instant.now(),
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage()
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorResponse> handleBadRequest(BadRequestException ex) {
        ErrorResponse error = new ErrorResponse(
                Instant.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage()
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGlobalException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
                Instant.now(),
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }


}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/exceptions/BadRequestException.java
==============================
package orsk.authmodule.exceptions;

public class BadRequestException extends RuntimeException {
    public BadRequestException(String message) {
        super(message);
    }
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/exceptions/UserAlreadyExistsException.java
==============================
package orsk.authmodule.exceptions;

public class UserAlreadyExistsException extends RuntimeException {
    public UserAlreadyExistsException(String message) {
        super(message);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/exceptions/InvalidTokenException.java
==============================
package orsk.authmodule.exceptions;

public class InvalidTokenException extends RuntimeException {
    public InvalidTokenException(String message) {
        super(message);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/exceptions/ErrorResponse.java
==============================
package orsk.authmodule.exceptions;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@AllArgsConstructor
public class ErrorResponse {
    private Instant timestamp;
    private int status;
    private String error;
    private String message;
}




==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/controller/AuthController.java
==============================
package orsk.authmodule.controller;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.web.bind.annotation.*;
import orsk.authmodule.dto.*;
import orsk.authmodule.exceptions.InvalidTokenException;
import orsk.authmodule.exceptions.MfaRequiredException;
import orsk.authmodule.service.AuthService;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private AuthService authService;

    @PostMapping("/register")
    public ResponseEntity<String> registerUser(@Valid @RequestBody RegistrationRequest registrationRequest) {
        authService.registerUser(registrationRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body("User registered successfully. Please check your email for verification instructions.");
    }

    @PostMapping("/login")
    public ResponseEntity<JwtAuthenticationResponse> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        try {
            JwtAuthenticationResponse response = authService.authenticateUser(loginRequest);
            return ResponseEntity.ok(response);
        } catch (MfaRequiredException e) {
            return ResponseEntity.status(HttpStatus.OK).body(null); // Indicate that MFA is required
        }
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<JwtAuthenticationResponse> refreshToken(@Valid @RequestBody TokenRefreshRequest request) {
        JwtAuthenticationResponse response = authService.refreshToken(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/logout")
    public ResponseEntity<String> logoutUser(@Valid @RequestBody LogoutRequest logoutRequest) {
        authService.logoutUser(logoutRequest);
        return ResponseEntity.ok("User logged out successfully.");
    }

    @PostMapping("/password-reset")
    public ResponseEntity<String> initiatePasswordReset(@Valid @RequestBody PasswordResetRequest passwordResetRequest) {
        authService.initiatePasswordReset(passwordResetRequest);
        return ResponseEntity.ok("Password reset instructions have been sent to your email.");
    }

    @PostMapping("/verify-email")
    public ResponseEntity<String> verifyEmail(@RequestParam("token") String token) {
        authService.verifyEmail(token);
        return ResponseEntity.ok("Email verified successfully.");
    }

    @PostMapping("/change-password")
    public ResponseEntity<String> changePassword(@Valid @RequestBody PasswordChangeRequest passwordChangeRequest) {
        authService.changePassword(passwordChangeRequest);
        return ResponseEntity.ok("Password changed successfully.");
    }

    @PostMapping("/verify-mfa")
    public ResponseEntity<String> verifyMfa(@Valid @RequestBody MfaVerificationRequest mfaVerificationRequest) {
        authService.verifyMfa(mfaVerificationRequest);
        return ResponseEntity.ok("MFA verification successful.");
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/AuthmoduleApplication.java
==============================
package orsk.authmodule;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AuthmoduleApplication {

    public static void main(String[] args) {
        SpringApplication.run(AuthmoduleApplication.class, args);
    }

}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/RefreshToken.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "refresh_tokens", indexes = @Index(columnList = "token", unique = true))
public class RefreshToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String token;

    @Column(nullable = false, name = "expiry_date")
    private Instant expiryDate;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/UserRole.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;

@Getter
@Setter
@Entity
@Table(name = "user_roles")

public class UserRole {
    @Id
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id", nullable = false)
    @OnDelete(action = OnDeleteAction.CASCADE)
    private User user;

    @Column(name = "role")
    private String role;

    @Column(name = "role_id", nullable = false)
    private Long roleId;

    @Id
    @Column(name = "id", nullable = false)
    private Long id;


}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/PasswordResetToken.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "password_reset_tokens", indexes = @Index(columnList = "token", unique = true))
public class PasswordResetToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String token;

    @ManyToOne
    @JoinColumn(nullable = false, name = "user_id")
    private User user;

    @Column(nullable = false)
    private Instant expiryDate;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/AuditLog.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "audit_logs")
public class AuditLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String action; // e.g., LOGIN_SUCCESS, LOGIN_FAILURE

    @Column(nullable = false)
    private String ipAddress;

    @Column(nullable = false)
    private Instant timestamp;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @Column(length = 500)
    private String details;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/MfaToken.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "mfa_tokens", indexes = @Index(columnList = "mfaCode", unique = true))
public class MfaToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String mfaCode;

    @Column(nullable = false)
    private Instant expiryDate;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(nullable = false)
    private Boolean used = false; // Default to false

    // Constructors, if needed
    public MfaToken() {}

    public MfaToken(String mfaCode, Instant expiryDate, User user) {
        this.mfaCode = mfaCode;
        this.expiryDate = expiryDate;
        this.user = user;
        this.used = false;
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/Privilege.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "privileges", indexes = @Index(columnList = "name", unique = true))
public class Privilege {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String name;

    @ManyToMany(mappedBy = "privileges", fetch = FetchType.LAZY)
    private Set<Role> roles = new HashSet<>();

    // Override equals and hashCode based on 'name'
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Privilege privilege = (Privilege) o;
        return Objects.equals(name, privilege.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/User.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "users", indexes = {
        @Index(columnList = "username", unique = true),
        @Index(columnList = "email", unique = true)
})
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, length = 100)
    private String password;

    @Column(nullable = false, unique = true, length = 255)
    private String email;

    @Column(nullable = false)
    private Boolean enabled = false;

    @Column(nullable = false, name = "consent_to_data_usage")
    private Boolean consentToDataUsage = false;

    @ManyToMany(fetch = FetchType.EAGER, cascade = { CascadeType.PERSIST, CascadeType.MERGE })
    @JoinTable(
            name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();

    // Other fields and relationships...

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<RefreshToken> refreshTokens = new HashSet<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<PasswordResetToken> passwordResetTokens = new HashSet<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<VerificationToken> verificationTokens = new HashSet<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<MfaToken> mfaTokens = new HashSet<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<AuditLog> auditLogs = new HashSet<>();

    @PreRemove
    private void preRemove() {
        roles.clear();
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/VerificationToken.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "verification_tokens", indexes = @Index(columnList = "token", unique = true))
public class VerificationToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String token;

    @ManyToOne
    @JoinColumn(nullable = false, name = "user_id")
    private User user;

    @Column(nullable = false)
    private Instant expiryDate;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/Device.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "devices")
public class Device {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String deviceId;

    @Column(nullable = false)
    private String deviceType; // e.g., MOBILE, DESKTOP

    @Column(nullable = false)
    private Instant registeredAt;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/Role.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "roles", indexes = {
        @Index(columnList = "name", unique = true)
})
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String name;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "roles_privileges",
            joinColumns = @JoinColumn(name = "role_id"),
            inverseJoinColumns = @JoinColumn(name = "privilege_id")
    )
    private Set<Privilege> privileges = new HashSet<>();

    // Override equals and hashCode based on 'name'
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Role role = (Role) o;
        return Objects.equals(name, role.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/model/Session.java
==============================
package orsk.authmodule.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;

@Getter
@Setter
@Entity
@Table(name = "sessions", indexes = @Index(columnList = "sessionId", unique = true))
public class Session {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String sessionId;

    @Column(nullable = false)
    private Instant createdAt;

    @Column(nullable = false)
    private Instant lastAccessedAt;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/service/UserService.java
==============================
package orsk.authmodule.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import orsk.authmodule.model.Role;
import orsk.authmodule.model.User;
import orsk.authmodule.repository.RoleRepository;
import orsk.authmodule.repository.UserRepository;


import java.util.Collections;

@Service("UserService")
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    public User registerNewUser(User user) {
        if (userRepository.findByUsername(user.getUsername()).isPresent()) {
            throw new RuntimeException("Username already exists");
        }
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        user.setEnabled(false); // User needs to be enabled after registration or email verification
        Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseThrow(() -> new RuntimeException("ROLE_USER not found"));
        user.setRoles(Collections.singleton(userRole));
        return userRepository.save(user);
    }
}



==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/service/MfaTokenService.java
==============================
package orsk.authmodule.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import orsk.authmodule.model.MfaToken;
import orsk.authmodule.repository.MfaTokenRepository;

import java.util.Optional;

@Service("MfaTokenService")
public class MfaTokenService {

    @Autowired
    private MfaTokenRepository mfaTokenRepository;

    public Optional<MfaToken> findByMfaCode(String mfaCode) {
        return mfaTokenRepository.findByMfaCode(mfaCode);
    }

    @Transactional
    public void save(MfaToken mfaToken) {
        mfaTokenRepository.save(mfaToken);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/service/AuditLogService.java
==============================
package orsk.authmodule.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import orsk.authmodule.model.AuditLog;
import orsk.authmodule.model.User;
import orsk.authmodule.repository.AuditLogRepository;

import java.time.Instant;

@Service("AuditLogService")
public class AuditLogService {

    @Autowired
    private AuditLogRepository auditLogRepository;

    public void logAction(User user, String action, String ipAddress, String details) {
        AuditLog auditLog = new AuditLog();
        auditLog.setUser(user);
        auditLog.setAction(action);
        auditLog.setIpAddress(ipAddress);
        auditLog.setTimestamp(Instant.now());
        auditLog.setDetails(details);
        auditLogRepository.save(auditLog);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/service/AuthService.java
==============================
package orsk.authmodule.service;

import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;
import orsk.authmodule.dto.*;
import orsk.authmodule.exceptions.EmailNotFoundException;
import orsk.authmodule.exceptions.InvalidTokenException;
import orsk.authmodule.exceptions.MfaRequiredException;
import orsk.authmodule.exceptions.UserAlreadyExistsException;
import orsk.authmodule.model.*;
import orsk.authmodule.repository.PasswordResetTokenRepository;
import orsk.authmodule.repository.RoleRepository;
import orsk.authmodule.repository.UserRepository;
import orsk.authmodule.repository.VerificationTokenRepository;
import orsk.authmodule.security.JwtTokenProvider;

import java.time.Instant;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

@Service("AuthService")
@Validated
public class AuthService {

    private static final Logger logger = LoggerFactory.getLogger(AuthService.class);

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private VerificationTokenRepository verificationTokenRepository;

    @Autowired
    private PasswordResetTokenRepository passwordResetTokenRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtTokenProvider tokenProvider;

    @Autowired
    private RefreshTokenService refreshTokenService;

    @Autowired
    private MfaTokenService mfaTokenService;

    @Autowired
    private AuditLogService auditLogService;

    // Token expiry configuration
    private static final long VERIFICATION_TOKEN_EXPIRY = 86400L; // 24 hours
    private static final long PASSWORD_RESET_TOKEN_EXPIRY = 3600L; // 1 hour
    private static final long MFA_TOKEN_EXPIRY = 300L; // 5 minutes

    @Transactional
    public void registerUser(@Valid RegistrationRequest registrationRequest) {
        if (userRepository.existsByUsernameOrEmail(registrationRequest.getUsername(), registrationRequest.getEmail())) {
            throw new UserAlreadyExistsException("Username or email already exists");
        }

        User user = new User();
        user.setUsername(registrationRequest.getUsername());
        user.setPassword(passwordEncoder.encode(registrationRequest.getPassword()));
        user.setEmail(registrationRequest.getEmail());
        user.setConsentToDataUsage(registrationRequest.getConsentToDataUsage());
        user.setEnabled(false); // User must verify email

        Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseThrow(() -> new RuntimeException("ROLE_USER not found"));
        user.setRoles(Set.of(userRole));

        userRepository.save(user);

        String token = generateVerificationToken(user);
        logger.info("Verification token generated for user {}: {}", user.getUsername(), token);

        // Placeholder for email service integration
        // emailService.sendVerificationEmail(user.getEmail(), token);

        auditLogService.logAction(user, "USER_REGISTERED", getClientIp(), "User registered successfully");
    }

    @Transactional
    public JwtAuthenticationResponse authenticateUser(@Valid LoginRequest loginRequest) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getEmail(),
                            loginRequest.getPassword()
                    )
            );

            if (authentication == null || !authentication.isAuthenticated()) {
                throw new BadCredentialsException("Invalid email or password");
            }

            User user = userRepository.findByEmail(loginRequest.getEmail())
                    .orElseThrow(() -> new UsernameNotFoundException("User not found"));

            if (!user.getEnabled()) {
                throw new RuntimeException("User account is not enabled");
            }

            // Check if MFA is required
            if (user.getRoles().stream().anyMatch(role -> role.getPrivileges().stream()
                    .anyMatch(privilege -> privilege.getName().equals("MFA_REQUIRED")))) {
                initiateMfa(user);
                auditLogService.logAction(user, "MFA_INITIATED", getClientIp(), "MFA initiated for user");
                throw new MfaRequiredException("MFA verification required");
            }

            String jwt = tokenProvider.generateToken(authentication);
            RefreshToken refreshToken = refreshTokenService.createRefreshToken(user.getUsername());

            auditLogService.logAction(user, "LOGIN_SUCCESS", getClientIp(), "User logged in successfully");

            return new JwtAuthenticationResponse(jwt, refreshToken.getToken());
        } catch (BadCredentialsException e) {
            logger.error("Authentication failed for email {}: {}", loginRequest.getEmail(), e.getMessage());
            auditLogService.logAction(null, "LOGIN_FAILURE", getClientIp(), "Invalid credentials for email: " + loginRequest.getEmail());
            throw e;
        } catch (MfaRequiredException e) {
            logger.info("MFA required for email {}: {}", loginRequest.getEmail(), e.getMessage());
            throw e;
        } catch (Exception e) {
            logger.error("Unexpected error during authentication for email {}: {}", loginRequest.getEmail(), e.getMessage());
            throw new RuntimeException("Authentication failed due to an unexpected error", e);
        }
    }

    @Transactional
    public JwtAuthenticationResponse refreshToken(@Valid TokenRefreshRequest request) {
        String requestRefreshToken = request.getRefreshToken();

        Optional<RefreshToken> refreshTokenOpt = refreshTokenService.findByToken(requestRefreshToken);

        if (refreshTokenOpt.isEmpty()) {
            throw new InvalidTokenException("Refresh token not found");
        }

        RefreshToken refreshToken = refreshTokenService.verifyExpiration(refreshTokenOpt.get());

        User user = refreshToken.getUser();

        String token = tokenProvider.generateTokenFromUsername(user.getUsername());
        logger.info("Refresh token used for user {}", user.getUsername());

        auditLogService.logAction(user, "TOKEN_REFRESHED", getClientIp(), "Access token refreshed using refresh token");

        return new JwtAuthenticationResponse(token, requestRefreshToken);
    }

    @Transactional
    public void logoutUser(@Valid LogoutRequest logoutRequest) {
        refreshTokenService.deleteByToken(logoutRequest.getRefreshToken());
        logger.info("User logged out with refresh token {}", logoutRequest.getRefreshToken());
        auditLogService.logAction(null, "USER_LOGOUT", getClientIp(), "User logged out with refresh token");
    }

    @Transactional
    public void initiatePasswordReset(@Valid PasswordResetRequest passwordResetRequest) {
        User user = userRepository.findByEmail(passwordResetRequest.getEmail())
                .orElseThrow(() -> new EmailNotFoundException("Email not found"));

        String token = UUID.randomUUID().toString();
        PasswordResetToken passwordResetToken = new PasswordResetToken();
        passwordResetToken.setToken(token);
        passwordResetToken.setUser(user);
        passwordResetToken.setExpiryDate(Instant.now().plusSeconds(PASSWORD_RESET_TOKEN_EXPIRY));

        passwordResetTokenRepository.save(passwordResetToken);

        logger.info("Password reset token generated for user {}: {}", user.getUsername(), token);

        // Placeholder for email service integration
        // emailService.sendPasswordResetEmail(user.getEmail(), token);

        auditLogService.logAction(user, "PASSWORD_RESET_INITIATED", getClientIp(), "Password reset initiated");
    }

    @Transactional
    public void verifyEmail(String token) {
        VerificationToken verificationToken = verificationTokenRepository.findByToken(token)
                .orElseThrow(() -> new InvalidTokenException("Invalid verification token"));

        if (verificationToken.getExpiryDate().isBefore(Instant.now())) {
            throw new InvalidTokenException("Verification token expired");
        }

        User user = verificationToken.getUser();
        user.setEnabled(true);

        userRepository.save(user);
        verificationTokenRepository.delete(verificationToken);

        logger.info("User {} email verified successfully", user.getUsername());

        auditLogService.logAction(user, "EMAIL_VERIFIED", getClientIp(), "User email verified successfully");
    }

    @Transactional
    public void changePassword(@Valid PasswordChangeRequest passwordChangeRequest) {
        String token = passwordChangeRequest.getToken();

        User user = userRepository.findByPasswordResetTokens_Token(token)
                .orElseThrow(() -> new InvalidTokenException("Invalid password reset token"));

        PasswordResetToken resetToken = passwordResetTokenRepository.findByToken(token)
                .orElseThrow(() -> new InvalidTokenException("Invalid password reset token"));

        // Validate token expiration
        if (resetToken.getExpiryDate().isBefore(Instant.now())) {
            throw new InvalidTokenException("Password reset token expired");
        }

        // Update the password
        user.setPassword(passwordEncoder.encode(passwordChangeRequest.getNewPassword()));
        user.setPasswordResetTokens(Set.of()); // Clear all password reset tokens

        userRepository.save(user);
        passwordResetTokenRepository.delete(resetToken);

        logger.info("Password successfully changed for user {}", user.getUsername());

        auditLogService.logAction(user, "PASSWORD_CHANGED", getClientIp(), "User changed password successfully");
    }

    @Transactional
    public void verifyMfa(@Valid MfaVerificationRequest mfaVerificationRequest) {
        String mfaCode = mfaVerificationRequest.getMfaCode();

        Optional<MfaToken> mfaTokenOpt = mfaTokenService.findByMfaCode(mfaCode);

        if (mfaTokenOpt.isEmpty()) {
            throw new InvalidTokenException("Invalid MFA code");
        }

        MfaToken mfaToken = mfaTokenOpt.get();

        if (mfaToken.getExpiryDate().isBefore(Instant.now())) {
            throw new InvalidTokenException("MFA code expired");
        }

        if (mfaToken.getUsed()) {
            throw new InvalidTokenException("MFA code has already been used");
        }

        User user = mfaToken.getUser();
        mfaToken.setUsed(true); // Mark MFA code as used
        mfaTokenService.save(mfaToken);

        // Generate JWT and Refresh Token
        String jwt = tokenProvider.generateTokenFromUsername(user.getUsername());
        RefreshToken refreshToken = refreshTokenService.createRefreshToken(user.getUsername());

        logger.info("MFA verified successfully for user {}", user.getUsername());

        auditLogService.logAction(user, "MFA_VERIFIED", getClientIp(), "User MFA verified successfully");

        // Optionally, return tokens or handle as per your application's flow
    }

    private String generateVerificationToken(User user) {
        String token = UUID.randomUUID().toString();

        VerificationToken verificationToken = new VerificationToken();
        verificationToken.setToken(token);
        verificationToken.setUser(user);
        verificationToken.setExpiryDate(Instant.now().plusSeconds(VERIFICATION_TOKEN_EXPIRY));

        verificationTokenRepository.save(verificationToken);
        return token;
    }

    private void initiateMfa(User user) {
        String mfaCode = generateMfaCode();
        MfaToken mfaToken = new MfaToken();
        mfaToken.setMfaCode(mfaCode);
        mfaToken.setUser(user);
        mfaToken.setExpiryDate(Instant.now().plusSeconds(MFA_TOKEN_EXPIRY));

        mfaTokenService.save(mfaToken);

        logger.info("MFA code generated for user {}: {}", user.getUsername(), mfaCode);

        // Placeholder for MFA code sending logic (e.g., SMS, Email, Authenticator App)
        // mfaService.sendMfaCode(user.getEmail(), mfaCode);
    }

    private String generateMfaCode() {
        // Generate a 6-digit random MFA code
        int code = (int) (Math.random() * 900000) + 100000;
        return String.valueOf(code);
    }

    private String getClientIp() {
        // Implement logic to retrieve client's IP address from the request
        // This typically involves accessing HttpServletRequest, which may require additional configuration
        return "0.0.0.0"; // Placeholder
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/service/RefreshTokenService.java
==============================
package orsk.authmodule.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import orsk.authmodule.exceptions.InvalidTokenException;
import orsk.authmodule.model.RefreshToken;
import orsk.authmodule.model.User;
import orsk.authmodule.repository.RefreshTokenRepository;
import orsk.authmodule.repository.UserRepository;

import java.time.Instant;
import java.util.Optional;
import java.util.UUID;

@Service("RefreshTokenService")
public class RefreshTokenService {

    private static final long REFRESH_TOKEN_EXPIRY = 604800L; // 7 days

    @Autowired
    private RefreshTokenRepository refreshTokenRepository;

    @Autowired
    private UserRepository userRepository;

    public Optional<RefreshToken> findByToken(String token) {
        return refreshTokenRepository.findByToken(token);
    }

    @Transactional
    public RefreshToken createRefreshToken(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));

        RefreshToken refreshToken = new RefreshToken();
        refreshToken.setUser(user);
        refreshToken.setExpiryDate(Instant.now().plusSeconds(REFRESH_TOKEN_EXPIRY));
        refreshToken.setToken(UUID.randomUUID().toString());

        return refreshTokenRepository.save(refreshToken);
    }

    public RefreshToken verifyExpiration(RefreshToken token) {
        if (token.getExpiryDate().isBefore(Instant.now())) {
            refreshTokenRepository.delete(token);
            throw new InvalidTokenException("Refresh token expired");
        }

        return token;
    }

    @Transactional
    public int deleteByUserId(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return refreshTokenRepository.deleteByUser(user);
    }

    @Transactional
    public void deleteByToken(String token) {
        refreshTokenRepository.findByToken(token).ifPresent(refreshTokenRepository::delete);
    }
}


==============================
File: /Users/simonbeckmann/IdeaProjects/CyberDashboar/src/authmoduleV/src/main/java/orsk/authmodule/service/CustomUserDetailsService.java
==============================
package orsk.authmodule.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.*;
import org.springframework.stereotype.Service;
import orsk.authmodule.model.Privilege;
import orsk.authmodule.model.Role;
import orsk.authmodule.model.User;
import orsk.authmodule.repository.UserRepository;

import java.util.List;
import java.util.stream.Collectors;

@Service("CustomUserDetailsService")
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String usernameOrEmail) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(usernameOrEmail)
                .or(() -> userRepository.findByEmail(usernameOrEmail))
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username or email: " + usernameOrEmail));

        List<SimpleGrantedAuthority> authorities = user.getRoles().stream()
                .flatMap(role -> role.getPrivileges().stream())
                .map(Privilege::getName)
                .distinct()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());

        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(),
                user.getEnabled(),
                true,
                true,
                true,
                authorities);
    }
}


